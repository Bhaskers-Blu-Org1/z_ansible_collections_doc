################################################################################
# Copyright (c) IBM Corporation 2020
################################################################################

################################################################################
# Description:
#    This playbook will perform document generation tasks based on the
#    collections in the certified-registry and on the configurations enabled in
#    this playbook.
# Tasks:
#    - Parse the certified registry
#    - Evaluate the registered certified collections
#    - Add new pending certified collections
#    - Pre-check requirements
#      - docs/source/<collection>/docs/zos-collections-index.rst
#    - Build HTML from RST using Sphinx
#    - Upload HTML web-server for review
#    - Commit go gh-pages
#
# Usage:
#    ansible-playbook -i inventory site-builder.yaml
################################################################################

---
- hosts: all
  gather_facts: no
  connection: local
  vars:
    ############################################################################
    # Configure variables as needed in inventory
    ############################################################################

    # Array of collection git submodules located under directory source/<...>
    ARRAY_OF_REGISTERED_COLLECTIONS: []

    # Array of collections in registry but NOT under directory source/<...>
    # in other words, collections pending acceptance
    ARRAY_OF_UNREGISTERED_COLLECTIONS: []

  # ##############################################################################
  # # Parse 'certified-registry' for certified contributors (key:value)
  # ##############################################################################

  tasks:
    # Read the registry for all its content
    - name: Parse the registry for repository values
      raw: cat certified-registry
      register: certified_collections

    - name: Display the collection repository names from the registry
      debug: msg="{{ item.split('=')[1] }}"
      with_items: "{{ certified_collections.stdout_lines }}"


    ############################################################################
    # Evaluate the state of all collections in the certified-registry
    ############################################################################

    # Stat all certified-registry collections
    - name: Check if Git submodule exists in the `source/` directory
      stat:
        path: source/{{ item.split('=')[1].split('.')[0] }}
      register: git_submodule
      with_items: "{{ certified_collections.stdout_lines }}"

    - name: Populate array with collections currently known to this repository
      set_fact:
        ARRAY_OF_REGISTERED_COLLECTIONS="{{ ARRAY_OF_REGISTERED_COLLECTIONS }} + [ '{{ item.item.split('=')[1].split('.')[0] }}' ]"
      with_items: "{{ git_submodule.results}}"
      when: item.stat.exists

    - name: Display the array of registered collections in this repository
      debug: msg="{{ ARRAY_OF_REGISTERED_COLLECTIONS }}"

    - name: Populate array with collections pending acceptance to this repository
      set_fact:
        ARRAY_OF_UNREGISTERED_COLLECTIONS="{{ ARRAY_OF_UNREGISTERED_COLLECTIONS }} + [ '{{ item.item.split('=')[1].split('.')[0] }}' ]"
      with_items: "{{ git_submodule.results}}"
      when: not item.stat.exists

    - name: Display the array of unregistered collections
      debug: msg="{{ ARRAY_OF_UNREGISTERED_COLLECTIONS }}"

    ############################################################################
    # Add new pending collections
    ############################################################################
    # If new collections are being added, set accept_new_collection_registrant=TRUE.
    # New collections must be added as Git submodules to the `source` directory.
    # TODO:  Can update this to use 'ARRAY_OF_NEW_COLLECTIONS'

    - name: Add Git submodules if we are accepting new collections
      # debug: msg="{{ item.item.split('=')[1] }}"
      shell: |
          touch .gitmodules
          git submodule add git@github.com:ansible-collections/{{ item }}.git source/{{ item }}
          cd source/{{ item }}
          git fetch --tags
          tag=$(git describe --tags `git rev-list --tags --max-count=1`)
          git checkout $tag
          cd ../..
      with_items: "{{ ARRAY_OF_UNREGISTERED_COLLECTIONS }}"
      register: git_add_submodules

    - name: Display the Git submodules added
      debug: msg="{{ git_add_submodules }}"
      # when: git_add_submodules.????

    ############################################################################
    # Update all collections (git submodules)
    ############################################################################
    # TODO: git submodule update --remote

    ############################################################################
    # Evaluate that the collections (git submodules) have required files
    ############################################################################

    - name: Stat file zos-collection-index.rst in all collections.
      stat:
        path: source/{{ item }}/docs/zos-collection-index.rst
      register: stat_collection_index_rst
      with_items: "{{ ARRAY_OF_REGISTERED_COLLECTIONS }}"

    - name: Display registered collections with zos-collection-index.rst
      debug: msg="{{ item.item }}"
      with_items: "{{ stat_collection_index_rst.results}}"
      when: item.stat.exists

      # Fail the build if collections don't meet requirements
    - name: Evaluate if the registered collections have the file 'source/<collection>/zos-collection-index.rst'.
      assert:
        that:
          - item.stat.exists
        success_msg: "Collection {{ item.item }} is valid."
        fail_msg: "Collection {{ item.item }} is NOT valid."
      with_items: "{{ stat_collection_index_rst.results}}"

    ############################################################################
    # Generate and view HTML
    ############################################################################

    - name: Clean up the directory and build the HTML
      raw: make clean; make html; make view-html;

    #- name: Decide if you want to continue to HTML deployment tasks
    #  pause: prompt='Continue deploying HTML? Press return to continue. Press Ctrl+c and then "a" to abort'

    ############################################################################
    # Deploy HTML to web-server for review if deploy_to_web_server=True
    ############################################################################

    - name: Copy files to remote host
      copy:
        src: build/html/index.html
        dest: /var/www/collection-doc
        owner: root
        group: root
        mode: 0755
        force: yes
      vars:
        ansible_become_password: "{{ webserver_password }}"
      delegate_to: "{{ web_server }}"
      remote_user: "{{ webserver_user }}"
      register: webserver_upload
      when: deploy_to_web_server

    - name: Uploading content for review.
      debug: msg="Successfully uploaded content for review at [ http://collection-doc.moonpie1.fyre.ibm.com/index.html ]"
      when: not webserver_upload.failed and deploy_to_web_server

    ############################################################################
    # Deploy HTML to gh-pages if deploy_to_gh_pages=True
    ############################################################################

    # TODO: Move gh-pages to a Git submodule over worktree
    
    - name: Add Git worktree gh-pages
      # debug: msg="{{ item.item.split('=')[1] }}"
      shell: |
          rsync -av build/html/ gh-pages/
          cd gh-pages
          git add .
          git status
          git commit -m "Automated commit to update documentation"
          git push
          cd ..
      register: git_add_worktree

    - name: Display Git worktree gh-pages added
      debug: msg="{{ git_add_worktree }}"
      # when: git_add_worktree.????

      ##########################################################################
      # TODO: Should we track a particular submodule branch?
      ##########################################################################
      # git submodule add -b master {{ item.item.split('=')[1] }}
      # git submodule init
      # If we track we can also support update to pull the new commits
      # git submodule update --remote
      # Currently leaning towards just using 'add' and then checking
      # out the latest tag
      ##########################################################################