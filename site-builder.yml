################################################################################
# Copyright (c) IBM Corporation 2020
################################################################################

################################################################################
# Description:
#    This playbook will perform document generation tasks based on the
#    collections in the `registry.yml` and on the configurations enabled in
#    this playbook.
# Tasks:
#    - Parse the certified registry
#    - Evaluate the registered certified collections
#    - Add new pending certified collections
#    - Pre-check requirements
#      - docs/source/<collection>/docs/zos-collections-index.rst
#    - Build HTML from RST using Sphinx
#    - Upload HTML web-server for review
#    - Commit go gh-pages
#
# Usage:
#    ansible-playbook -i inventory site-builder.yaml
#    ansible-playbook -i inventory site-builder.yml --ask-vault-pass
################################################################################

---
- hosts: all
  gather_facts: no
  connection: local
  vars:
    ############################################################################
    # Configure variables as needed in inventory
    ############################################################################

    # Array of collection git submodules located under directory source/<...>
    ARRAY_OF_REGISTERED_COLLECTIONS: []

    # Array of collections in registry but NOT under directory source/<...>
    # in other words, collections pending acceptance
    ARRAY_OF_UNREGISTERED_COLLECTIONS: []

  # ##############################################################################
  # # Parse 'registry.yml' for certified contributors (key:value)
  # ##############################################################################

  tasks:
    - name: Parse the registry for collection configurations
      include_vars: registry.yml

    - name: Display the registry details using lookup
      debug:
        msg: "Collection = {{ item.key }}, git = {{ item.value.git }}, stable = {{ item.value.stable }}, latest = {{ item.value.latest }}"
      loop: "{{ lookup('dict', collections) }}"

    - name: Display the collection repository names from the registry
      debug:
         var: collections[item]
          # Display the git url for the collection
          # var: collections[item].git
          # msg: "{{item}}"
      with_items: "{{collections}}"

    ############################################################################
    # Evaluate the state of all collections currently in the repo and compare
    # them to the certified-registry, then add the new collections to this repo
    # if accept_new_registry_collections==True. Allowing for boolean
    # accept_new_registry_collections provides the ability to run and test the
    # script before including the new collections.
    ############################################################################

    # Stat all known collections in this repository
    - name: Check if Git submodule exists in the `source/` directory
      stat:
        path: source/{{ item }}
      register: git_submodule
      with_items: "{{collections}}"

    - name: Display the submodule stats
      debug: msg="{{ git_submodule }}"

    - name: Populate array with unregistered collections (collections that are not submodules)
      set_fact:
        ARRAY_OF_UNREGISTERED_COLLECTIONS="{{ ARRAY_OF_UNREGISTERED_COLLECTIONS }} + [ '{{ item.item}}' ]"
      with_items: "{{ git_submodule.results}}"
      when: not item.stat.exists

    - name: Display the array of unregistered collections
      debug: msg="{{ ARRAY_OF_UNREGISTERED_COLLECTIONS }}"

      # Add these additional commands to the next task if you want to automate
      # getting the latest tags, better we use the registry as the default instead
      # cd source/{{ item }}
      # git fetch --tags
      # tag=$(git describe --tags `git rev-list --tags --max-count=1`)
      # git checkout $tag
      # cd ../..
    - name: Add Git submodules if we are accepting new collections
      shell: |
          touch .gitmodules
          git submodule add git@github.com:ansible-collections/{{ item }}.git source/{{ item }}
      with_items: "{{ ARRAY_OF_UNREGISTERED_COLLECTIONS }}"
      register: git_add_submodules
      when: accept_new_registry_collections

    # Stat all known collections in this repository again after having added unregistered collections
    - name: Check if Git submodule exists in the `source/` directory
      stat:
        path: source/{{ item }}
      register: git_submodule
      with_items: "{{collections}}"

    - name: Display the submodule stats
      debug: msg="{{ git_submodule }}"

    - name: Populate an array with registered collections in this repository
      set_fact:
        ARRAY_OF_REGISTERED_COLLECTIONS="{{ ARRAY_OF_REGISTERED_COLLECTIONS }} + [ '{{ item.item }}' ]"
      with_items: "{{ git_submodule.results}}"
      when: item.stat.exists

    - name: Display the array of registered collections in this repository
      debug: msg="{{ ARRAY_OF_REGISTERED_COLLECTIONS }}"

    ############################################################################
    # Checkout the correct branch version based on the registry, git  pull the
    # latest changes.
    # TODO:
    #   Consider defaulting to the latest branch (see above ), tag=$(git describe --tags `git rev-list --tags --max-count=1`)
    #   Consider checking out as latest and stable, ie `git checkout v1.1.0-beta1 -b latest`
    ############################################################################

    - name: Git checkout the latest branch or tag provided in the registry
      shell: |
          cd source/{{ item.key }}
          git checkout {{ item.value.latest }}
          git pull origin {{ item.value.latest }}
      loop: "{{ lookup('dict', collections) }}"
      register: git_checkout_latest
      when: item.key in ARRAY_OF_REGISTERED_COLLECTIONS

    - name: Display the checkout
      debug: msg="{{ git_checkout_latest }}"

    - name: Git checkout the stable branch or tag provided in the registry
      shell: |
          cd source/{{ item.key }}
          git checkout {{ item.value.stable }}
          git pull origin {{ item.value.stable }}
      loop: "{{ lookup('dict', collections) }}"
      register: git_checkout_stable
      when: item.key in ARRAY_OF_REGISTERED_COLLECTIONS
      ignore_errors: yes

    - name: Display Git stable checkout
      debug: msg="{{ git_checkout_stable }}"
      when: git_checkout_stable

    ############################################################################
    # Update all collections (git submodules) - this is now done above
    # Commands that DON'T work for this are:
    #   - git submodule foreach git pull origin master
    #   - git submodule update --recursive --remote
    # - name: Git update all registered collections in this repository
    #   shell: |
    #       git submodule update --recursive --remote
    # ##########################################################################

    ############################################################################
    # Evaluate that the collections (git submodules) have required files
    ############################################################################

    - name: Stat file zos-collection-index.rst in all collections.
      stat:
        path: source/{{ item }}/docs/zos-collection-index.rst
      register: stat_collection_index_rst
      with_items: "{{ ARRAY_OF_REGISTERED_COLLECTIONS }}"

    - name: Display registered collections with zos-collection-index.rst
      debug: msg="{{ item.item }}"
      with_items: "{{ stat_collection_index_rst.results}}"
      when: item.stat.exists

      # Fail the build if collections don't meet requirements
    - name: Evaluate if the registered collections have the file 'source/<collection>/zos-collection-index.rst'.
      assert:
        that:
          - item.stat.exists
        success_msg: "Collection {{ item.item }} is valid."
        fail_msg: "Collection {{ item.item }} is NOT valid."
      with_items: "{{ stat_collection_index_rst.results}}"

    # ############################################################################
    # # Generate and view HTML
    # ############################################################################

    - name: Clean up the directory and build the HTML
      raw: make clean; make html; make view-html;

    # TODO: For now leave this prompt till we automate so we an kill the playbook if we are not happy with the generated HTML
    - name: Decide if you want to continue to HTML deployment tasks
      pause: prompt='Continue deploying HTML? Press return to continue. Press Ctrl+c and then "a" to abort'

    # ############################################################################
    # # Deploy HTML to web-server for review if deploy_to_web_server=True
    # ############################################################################

    - name: Copy files to LAN Apache server for review
      copy:
        src: build/html/index.html
        dest: /var/www/collection-doc
        owner: root
        group: root
        mode: 0755
        force: yes
      vars:
        ansible_become_password: "{{ webserver_password }}"
      delegate_to: "{{ web_server }}"
      remote_user: "{{ webserver_user }}"
      register: webserver_upload
      when: deploy_to_web_server

    - name: Uploaded content for review.
      debug: msg="Successfully uploaded content for review at [ http://collection-doc.{{ web_server }}/index.html ]"
      when: deploy_to_web_server and webserver_upload and not webserver_upload.failed

    # ############################################################################
    # # Deploy HTML to gh-pages if deploy_to_gh_pages=True
    # ############################################################################
    - name: Copy the generated HTML from `build/html/` to `site/gh-pages/`
      shell: |
          cp -R build/html/* site/gh-pages
          cd site/gh-pages
          git add .
          git status
          git commit -m "Automated commit to update documentation"
          git push
          cd ../..
      register: git_update_doc

    # See https://ibm.github.io/z_ansible_collections_doc/index.html
    - name: Display site/gh-pages updated HTML content
      debug: msg="{{ git_update_doc }}"

    # TODO: Test this on the next deployment
    # - name: Display site/gh-pages updated HTML content
    #   debug: msg="Successfully committed documentation to site/gh-pages viewable at [ https://ibm.github.io/z_ansible_collections_doc/index.html ]"
    #   when: git_update_doc.false and (stdout_lines | join('') | search('Automated commit'))
    #   stdout_lines
